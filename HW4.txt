1. Выкачать свой репозиторий с помощью ssh способа.
Создал на сервере ssh-ключ
$ ssh-keygen -t ed25519
далее копирую публичный ключ и иду на github в профиль -> settings -> SSH keys -> добавляем новый ключ -> вставляем скопированный публичный ключ
изначально копирую свой гит 
$ git clone https://github.com/Vyacheslav94/python_lesson_devops.git
потом меняю url на вход для ssh
$ git remote add origin git@github.com:Vyacheslav94/python_lesson_devops.git
проверяю
git remote -v
после первого push попросит подтвердить fingerprint - далее все будет пушится на удаленный репозиторий без паролей!
---------------------------------------------------------------------------------------------------------------------------------------------------
2. С помощью .gitignore, сделать так, чтобы все файлы *.txt не попадали в репозиторий.
Создаем в локальном репозитории файл .gitignore. В этом файле указываю какие файлы или директории нужно игнорировать.
Для того чтобы игнорировать все файлы с расширением txt пишем в файле .gitignore:
*.txt
git status
git add .gitignore
git commit -m "add .gitignore"
git push
Всё, все новые созданные файлы будут игнорироваться и не будут оторажаться в репозитории.
---------------------------------------------------------------------------------------------------------------------------------------------------
3. Изучить что такое git cherry-pick.
Команда git cherry-pick используется для выбора отдельных коммитов из одной ветки и применения их к другой ветке. 
Это полезно, когда нам нужно перенести конкретные изменения, не объединяя всю ветку.

Пример
Предположим, у нас есть две ветки: main и feature. В ветке feature мы сделали несколько коммитов, но хотим перенести только
один из них в ветку main.

Переключимся на ветку main:

git checkout main
Найдём хэш коммита, который мы хотим перенести. Мы можете использовать команду git log в ветке feature, 
чтобы увидеть список коммитов:

git log feature
Допустим, мы видим коммит с хэшом abc1234, который мы хотим перенести.

Выполняем команду cherry-pick:

git cherry-pick abc1234
После выполнения этой команды изменения из коммита abc1234 будут применены к нашей текущей ветке main. 
Если все прошло успешно, мы получим новый коммит в ветке main, который содержит изменения из выбранного коммита.

Если в процессе возникнут конфликты, Git уведомит нас, и нам нужно будет их разрешить перед завершением операции.
Мы можем перенести несколько коммитов, указав их хэши через пробел или указав диапазон коммитов.
Таким образом, git cherry-pick позволяет нам избирательно переносить изменения между ветками, что может быть 
очень полезно при работе над проектами.
---------------------------------------------------------------------------------------------------------------------------------------------------
4. Продемонстрировать применение git cherry-pick на собственном репозитории (придумать любой пример).
Создал в ветке master файл
echo "somelog" > logfile.log
git add .
git commit -m "create logfile.log"
git push
git log  видим что номер commita a66a86aea6bdcc38f12bf8d3158f7ff77854c51e
перехожу на ветку HomeWork4
git branch
* HomeWork4
  HomeWork5
  master
git cherry-pick a66a86aea6bdcc38f12bf8d3158f7ff77854c51e
[HomeWork4 f7b28c5] create logfile
 Date: Tue Feb 18 21:24:11 2025 +0300
 1 file changed, 1 insertion(+)
 create mode 100644 logfile.log
Файл создался и закомитился в новую ветку
git push
logfile.log запушился в новую ветку
---------------------------------------------------------------------------------------------------------------------------------------------------
5. Какая разница между git rebase и git merge ?
Git rebase и git merge — это два способа объединения изменений из одной ветки в другую, но они работают по-разному.

Git merge:

При использовании merge мы берем изменения из одной ветки и объединяем их с другой.
Это создает новый коммит "слияния", который сохраняет историю обеих веток.
История остается "ветвистой", и мы можем видеть, когда и как происходили слияния.
Git rebase:

Rebase "переписывает" историю. Он берет все коммиты из одной ветки и "перемещает" их на конец другой ветки.
Это создает линейную историю, как будто все изменения были сделаны последовательно.
Мы не увидим коммиты слияния, и история будет выглядеть чище, но мы теряем информацию о том, когда именно происходили слияния.
В общем, если нам нужна простая и понятная история, лучше использовать rebase. 
Если мы хотим сохранить полную историю изменений и слияний, используем merge.
---------------------------------------------------------------------------------------------------------------------------------------------------
6. Какая разница между git pull и git fetch ?
Git pull и git fetch — это команды, которые используются для обновления вашей локальной копии репозитория, но они делают это по-разному.

Git fetch: 
Когда мы выполняем fetch, Git загружает все новые изменения из удалённого репозитория, но не применяет их к нашей текущей ветке. 
Это как если бы мы просто проверили, что нового произошло, но ничего не меняли в своей работе. 
Мы можем просмотреть изменения и решить, что с ними делать.

Git pull: 
Pull — это комбинация fetch и merge. Когда мы выполняем pull, Git сначала загружает новые изменения (как при fetch), 
а затем автоматически пытается объединить их с нашей текущей веткой. Это значит, что наши изменения могут быть сразу обновлены 
новыми изменениями из удалённого репозитория.

В общем, fetch позволяет нам получить информацию о новых изменениях, а pull сразу применяет эти изменения к нашей работе.
---------------------------------------------------------------------------------------------------------------------------------------------------
7. Что такое git submodule ?
Git submodule — это способ включения одного Git-репозитория внутри другого. 
Представим, что у нас есть основной проект, и мы хотим добавить в него другой проект (например, библиотеку или компонент), 
который также находится в отдельном репозитории. Вместо того чтобы копировать файлы вручную, мы можем использовать submodule.

Когда мы добавляем submodule, Git создает ссылку на другой репозиторий. Это позволяет нам управлять зависимостями между проектами, 
сохраняя их в актуальном состоянии. Мы можем обновлять submodule, чтобы получить последние изменения из его репозитория, и при этом 
основной проект останется организованным.

В общем, git submodule помогает нам работать с несколькими связанными проектами, не теряя при этом контроль над их версиями и изменениями.
---------------------------------------------------------------------------------------------------------------------------------------------------
8. Изучить гит стратегии https://bool.dev/blog/detail/git-branching-strategies
Изучил
---------------------------------------------------------------------------------------------------------------------------------------------------
9. Установить Docker на Ubuntu.
Установлен Docker и Docker-Compose, history:
   58  sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
   59  sudo chmod a+r /etc/apt/keyrings/docker.asc
   60  ll /etc/apt/keyrings/
   61  echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
   62    $(. /etc/os-release && echo "$VERSION_CODENAME") stable" |   sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
   63  sudo apt update
   64  apt-cache policy docker-ce
   65  sudo apt install docker-ce
   66  sudo systemctl status docker
